{
  "version": 3,
  "sources": ["../../@somnia-chain/streams/src/services/viem/index.ts", "../../@somnia-chain/streams/src/services/smart-contracts/address/index.ts", "../../@somnia-chain/streams/src/services/smart-contracts/abi/Streams/index.ts", "../../@somnia-chain/streams/src/services/smart-contracts/abi/index.ts", "../../@somnia-chain/streams/src/types/utils/index.ts", "../../@somnia-chain/streams/src/services/smart-contracts/index.ts", "../../@somnia-chain/streams/src/services/logs/index.ts", "../../@somnia-chain/streams/src/modules/streams/encoder/index.ts", "../../@somnia-chain/streams/src/constants/index.ts", "../../@somnia-chain/streams/src/utils/validation.ts", "../../@somnia-chain/streams/src/modules/streams/index.ts", "../../@somnia-chain/streams/src/index.ts"],
  "sourcesContent": ["import { \n    Address,\n    Abi,\n    Account,\n    TransactionReceipt,\n    getContract as getContractViem,\n    WalletClient,\n} from \"viem\"\nimport { ContractAddressAndAbi } from \"@/services/smart-contracts\"\nimport { Client } from \"@/types\"\n \nexport class Viem {\n    client: Client\n    private chainId: number = 0\n\n    constructor(client: Client) {\n        this.client = client;\n    }\n\n    async getChainId(): Promise<number> {\n        if (this.chainId === 0) {\n            this.chainId = await this.client.public.getChainId()\n        }\n        return this.chainId\n    }\n\n    getContract(contractInfo: ContractAddressAndAbi) {\n        return getContractViem({\n            address: contractInfo.address,\n            abi: contractInfo.abi,\n            client: this.client.public\n        })\n    }\n\n    async readContract<T>(address: Address, abi: Abi, functionName: string, args: unknown[] = []) {\n        return this.client.public.readContract({\n            address,\n            abi,\n            functionName,\n            args\n        }) as Promise<T>\n    }\n\n    async writeContract(\n        address: Address,\n        abi: Abi,\n        functionName: string,\n        args: unknown[] = [],\n        value: bigint = BigInt(0)\n    ) {\n        if (!this.client.wallet) {\n            return null\n        }\n        const account: `0x${string}` | Account | null = this.client.wallet.account ?? null\n        return this.client.wallet.writeContract({\n            address,\n            abi,\n            functionName,\n            args,\n            value,\n            account,\n            chain: this.client.wallet.chain\n        })\n    }\n\n    async waitForTransaction(hash: `0x${string}`): Promise<TransactionReceipt> {\n        return this.client.public.waitForTransactionReceipt({\n            hash\n        })\n    }\n\n    async getCurrentAccounts(): Promise<Address[]> {\n\n        // If a wallet client is not injected, stop early\n        if (!this.client.wallet) {\n            throw new Error(\"No wallet client\")\n        }\n\n        let accounts: Address[] = []\n        if (this.client.wallet.account) {\n            // If we have a single account, push that as the only address\n            accounts.push(this.client.wallet.account.address)\n        } else {\n            // A different wallet client type has been supplied\n            // Check for accounts using the regular viem wallet client\n            try {\n                const viemWalletClient = this.client.wallet as WalletClient\n                accounts = await viemWalletClient.getAddresses()\n            } catch {\n                // Do nothing here - we have the ability to catch the error later\n            }\n        }\n\n        if (accounts.length === 0) {\n            throw new Error(\"No wallets detected\")\n        }\n\n        return accounts\n    }\n\n}", "import {\n    ContractRef,\n    KnownContracts,\n    ContractAddressByChain\n} from \"@/types\"\nimport { Chains } from \"@/services/smart-contracts/constants\"\nimport {\n    isAddress,\n    Address,\n    zeroAddress,\n    getAddress,\n} from \"viem\"\n\nconst STREAMS_LIBRARY_BY_CHAIN: ContractAddressByChain = {\n    [Chains.SomniaMainnet]: zeroAddress,\n    [Chains.SomniaTestnet]: getAddress(\n        \"0x6AB397FF662e42312c003175DCD76EfF69D048Fc\"\n    ),\n}\n\nconst KnownContractsByChain: Record<KnownContracts, Record<string, Address>> = {\n    [KnownContracts.STREAMS]: STREAMS_LIBRARY_BY_CHAIN,\n}\n\nexport async function getContractAddress(ref: ContractRef): Promise<Address | null> {\n    if (ref.internal && ref.chainId) {\n        return KnownContractsByChain[ref.internal][ref.chainId.toString()] ?? null\n    } else if (ref.address) {\n        if (!isAddress(ref.address, { strict: false })) {\n            throw new Error(\"Invalid address supplied\")\n        }\n        return ref.address!\n    }\n    return null\n}", "import { Abi } from \"viem\"\n\nexport async function StreamsABI(): Promise<Abi> {\n    return [\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"address\",\n          \"name\": \"initialOwner\",\n          \"type\": \"address\"\n        }\n      ],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"constructor\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"EventSchemaAlreadyRegistered\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"EventSchemaNotRegistered\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"EventTopicAlreadyRegistered\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"IDAlreadyUsed\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"IdentityAlreadyExists\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"IdentityDoesNotExist\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"IncorrectNumberOfTopics\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"InvalidArrayLength\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"InvalidDataLength\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"InvalidIdentity\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"InvalidIndex\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"InvalidRange\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"InvalidSelfReference\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"InvalidSize\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"MaxArrayLengthExceeded\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"NoCalldata\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"NoData\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"address\",\n          \"name\": \"owner\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"OwnableInvalidOwner\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"address\",\n          \"name\": \"account\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"OwnableUnauthorizedAccount\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"ParentSchemaNotRegistered\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"SchemaAlreadyRegistered\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"SchemaNotRegistered\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"TooManyIndexedParams\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"TooManyTopics\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"Unauthorized\",\n      \"type\": \"error\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"ZeroValue\",\n      \"type\": \"error\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": true,\n          \"internalType\": \"bytes32\",\n          \"name\": \"schemaId\",\n          \"type\": \"bytes32\"\n        },\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"publisher\",\n          \"type\": \"address\"\n        },\n        {\n          \"indexed\": true,\n          \"internalType\": \"bytes32\",\n          \"name\": \"dataId\",\n          \"type\": \"bytes32\"\n        }\n      ],\n      \"name\": \"ESStoreEvent\",\n      \"type\": \"event\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": true,\n          \"internalType\": \"bytes32\",\n          \"name\": \"eventTopic\",\n          \"type\": \"bytes32\"\n        },\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"emitter\",\n          \"type\": \"address\"\n        },\n        {\n          \"indexed\": false,\n          \"internalType\": \"bool\",\n          \"name\": \"isEmitter\",\n          \"type\": \"bool\"\n        }\n      ],\n      \"name\": \"EmitterUpdated\",\n      \"type\": \"event\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"wallet\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"IdentityCreated\",\n      \"type\": \"event\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"wallet\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"IdentityDeleted\",\n      \"type\": \"event\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": true,\n          \"internalType\": \"bytes32\",\n          \"name\": \"eventTopic\",\n          \"type\": \"bytes32\"\n        },\n        {\n          \"indexed\": false,\n          \"internalType\": \"bool\",\n          \"name\": \"isOpen\",\n          \"type\": \"bool\"\n        }\n      ],\n      \"name\": \"IsEventEmissionOpen\",\n      \"type\": \"event\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": false,\n          \"internalType\": \"enum RoleControl.Role\",\n          \"name\": \"role\",\n          \"type\": \"uint8\"\n        },\n        {\n          \"indexed\": false,\n          \"internalType\": \"bool\",\n          \"name\": \"isOpen\",\n          \"type\": \"bool\"\n        }\n      ],\n      \"name\": \"IsRoleOpenSet\",\n      \"type\": \"event\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"previousOwner\",\n          \"type\": \"address\"\n        },\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"newOwner\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"OwnershipTransferred\",\n      \"type\": \"event\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": false,\n          \"internalType\": \"bool\",\n          \"name\": \"bypassed\",\n          \"type\": \"bool\"\n        }\n      ],\n      \"name\": \"RoleChecksBypassToggled\",\n      \"type\": \"event\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"wallet\",\n          \"type\": \"address\"\n        },\n        {\n          \"indexed\": true,\n          \"internalType\": \"enum RoleControl.Role\",\n          \"name\": \"role\",\n          \"type\": \"uint8\"\n        }\n      ],\n      \"name\": \"RoleGranted\",\n      \"type\": \"event\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": true,\n          \"internalType\": \"address\",\n          \"name\": \"wallet\",\n          \"type\": \"address\"\n        },\n        {\n          \"indexed\": true,\n          \"internalType\": \"enum RoleControl.Role\",\n          \"name\": \"role\",\n          \"type\": \"uint8\"\n        }\n      ],\n      \"name\": \"RoleRevoked\",\n      \"type\": \"event\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": true,\n          \"internalType\": \"bytes32\",\n          \"name\": \"schemaId\",\n          \"type\": \"bytes32\"\n        }\n      ],\n      \"name\": \"SchemaRegistered\",\n      \"type\": \"event\"\n    },\n    {\n      \"anonymous\": false,\n      \"inputs\": [\n        {\n          \"indexed\": true,\n          \"internalType\": \"bytes32\",\n          \"name\": \"eventTopic\",\n          \"type\": \"bytes32\"\n        },\n        {\n          \"indexed\": false,\n          \"internalType\": \"string\",\n          \"name\": \"id\",\n          \"type\": \"string\"\n        }\n      ],\n      \"name\": \"SchemaRegistered\",\n      \"type\": \"event\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"MAX_NUM_EVM_INDEXED_PARAMS\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"bypassRoleChecks\",\n      \"outputs\": [\n        {\n          \"internalType\": \"bool\",\n          \"name\": \"\",\n          \"type\": \"bool\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"string\",\n          \"name\": \"schemaSpec\",\n          \"type\": \"string\"\n        }\n      ],\n      \"name\": \"computeSchemaId\",\n      \"outputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"\",\n          \"type\": \"bytes32\"\n        }\n      ],\n      \"stateMutability\": \"pure\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"address\",\n          \"name\": \"walletAddress\",\n          \"type\": \"address\"\n        },\n        {\n          \"internalType\": \"enum RoleControl.Role[]\",\n          \"name\": \"initialRoles\",\n          \"type\": \"uint8[]\"\n        }\n      ],\n      \"name\": \"createWalletIdentity\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"address\",\n          \"name\": \"wallet\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"deleteIdentity\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"components\": [\n            {\n              \"internalType\": \"string\",\n              \"name\": \"id\",\n              \"type\": \"string\"\n            },\n            {\n              \"internalType\": \"bytes32[]\",\n              \"name\": \"argumentTopics\",\n              \"type\": \"bytes32[]\"\n            },\n            {\n              \"internalType\": \"bytes\",\n              \"name\": \"data\",\n              \"type\": \"bytes\"\n            }\n          ],\n          \"internalType\": \"struct EventSource.EventData[]\",\n          \"name\": \"events\",\n          \"type\": \"tuple[]\"\n        }\n      ],\n      \"name\": \"emitEvents\",\n      \"outputs\": [\n        {\n          \"internalType\": \"bool\",\n          \"name\": \"success\",\n          \"type\": \"bool\"\n        }\n      ],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"components\": [\n            {\n              \"internalType\": \"bytes32\",\n              \"name\": \"id\",\n              \"type\": \"bytes32\"\n            },\n            {\n              \"internalType\": \"bytes32\",\n              \"name\": \"schemaId\",\n              \"type\": \"bytes32\"\n            },\n            {\n              \"internalType\": \"bytes\",\n              \"name\": \"data\",\n              \"type\": \"bytes\"\n            }\n          ],\n          \"internalType\": \"struct DataSchemaLibrary.DataStream[]\",\n          \"name\": \"dataStreams\",\n          \"type\": \"tuple[]\"\n        }\n      ],\n      \"name\": \"esstores\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"topic\",\n          \"type\": \"bytes32\"\n        }\n      ],\n      \"name\": \"eventIdFromTopic\",\n      \"outputs\": [\n        {\n          \"internalType\": \"string\",\n          \"name\": \"id\",\n          \"type\": \"string\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"getAllIdentities\",\n      \"outputs\": [\n        {\n          \"components\": [\n            {\n              \"internalType\": \"address\",\n              \"name\": \"walletAddress\",\n              \"type\": \"address\"\n            },\n            {\n              \"internalType\": \"enum RoleControl.Role[]\",\n              \"name\": \"roles\",\n              \"type\": \"uint8[]\"\n            }\n          ],\n          \"internalType\": \"struct RoleControl.IdentityView[]\",\n          \"name\": \"\",\n          \"type\": \"tuple[]\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"schemaId\",\n          \"type\": \"bytes32\"\n        },\n        {\n          \"internalType\": \"address\",\n          \"name\": \"publisher\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"getAllPublisherDataForSchema\",\n      \"outputs\": [\n        {\n          \"internalType\": \"bytes[]\",\n          \"name\": \"\",\n          \"type\": \"bytes[]\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"getAllRegisteredEventIds\",\n      \"outputs\": [\n        {\n          \"internalType\": \"string[]\",\n          \"name\": \"\",\n          \"type\": \"string[]\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"getAllSchemas\",\n      \"outputs\": [\n        {\n          \"internalType\": \"string[]\",\n          \"name\": \"\",\n          \"type\": \"string[]\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"getAllWallets\",\n      \"outputs\": [\n        {\n          \"internalType\": \"address[]\",\n          \"name\": \"\",\n          \"type\": \"address[]\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"idx\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"name\": \"getEventIdAtIndex\",\n      \"outputs\": [\n        {\n          \"internalType\": \"string\",\n          \"name\": \"\",\n          \"type\": \"string\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"string[]\",\n          \"name\": \"ids\",\n          \"type\": \"string[]\"\n        }\n      ],\n      \"name\": \"getEventSchemasById\",\n      \"outputs\": [\n        {\n          \"components\": [\n            {\n              \"components\": [\n                {\n                  \"internalType\": \"string\",\n                  \"name\": \"name\",\n                  \"type\": \"string\"\n                },\n                {\n                  \"internalType\": \"string\",\n                  \"name\": \"paramType\",\n                  \"type\": \"string\"\n                },\n                {\n                  \"internalType\": \"bool\",\n                  \"name\": \"isIndexed\",\n                  \"type\": \"bool\"\n                }\n              ],\n              \"internalType\": \"struct EventSource.Parameter[]\",\n              \"name\": \"params\",\n              \"type\": \"tuple[]\"\n            },\n            {\n              \"internalType\": \"bytes32\",\n              \"name\": \"eventTopic\",\n              \"type\": \"bytes32\"\n            }\n          ],\n          \"internalType\": \"struct EventSource.EventSchema[]\",\n          \"name\": \"schemas\",\n          \"type\": \"tuple[]\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"schemaId\",\n          \"type\": \"bytes32\"\n        },\n        {\n          \"internalType\": \"address\",\n          \"name\": \"publisher\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"getLastPublishedDataForSchema\",\n      \"outputs\": [\n        {\n          \"internalType\": \"bytes\",\n          \"name\": \"\",\n          \"type\": \"bytes\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"schemaId\",\n          \"type\": \"bytes32\"\n        },\n        {\n          \"internalType\": \"address\",\n          \"name\": \"publisher\",\n          \"type\": \"address\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"idx\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"name\": \"getPublisherDataForSchemaAtIndex\",\n      \"outputs\": [\n        {\n          \"internalType\": \"bytes\",\n          \"name\": \"\",\n          \"type\": \"bytes\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"schemaId\",\n          \"type\": \"bytes32\"\n        },\n        {\n          \"internalType\": \"address\",\n          \"name\": \"publisher\",\n          \"type\": \"address\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"start\",\n          \"type\": \"uint256\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"end\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"name\": \"getPublisherDataForSchemaInRange\",\n      \"outputs\": [\n        {\n          \"internalType\": \"bytes[]\",\n          \"name\": \"\",\n          \"type\": \"bytes[]\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"idx\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"name\": \"getSchema\",\n      \"outputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"schemaId\",\n          \"type\": \"bytes32\"\n        },\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"parentSchemaId_\",\n          \"type\": \"bytes32\"\n        },\n        {\n          \"internalType\": \"string\",\n          \"name\": \"schema\",\n          \"type\": \"string\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"getTotalNumberOfRegisteredEventSchemas\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"address\",\n          \"name\": \"wallet\",\n          \"type\": \"address\"\n        },\n        {\n          \"internalType\": \"enum RoleControl.Role\",\n          \"name\": \"role\",\n          \"type\": \"uint8\"\n        }\n      ],\n      \"name\": \"grantRole\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"string\",\n          \"name\": \"id\",\n          \"type\": \"string\"\n        }\n      ],\n      \"name\": \"idToSchemaId\",\n      \"outputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"schemaId\",\n          \"type\": \"bytes32\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"topic\",\n          \"type\": \"bytes32\"\n        },\n        {\n          \"internalType\": \"address\",\n          \"name\": \"caller\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"isCallerAuthorisedEmitter\",\n      \"outputs\": [\n        {\n          \"internalType\": \"bool\",\n          \"name\": \"isEmitter\",\n          \"type\": \"bool\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"topic\",\n          \"type\": \"bytes32\"\n        }\n      ],\n      \"name\": \"isEventEmissionOpen\",\n      \"outputs\": [\n        {\n          \"internalType\": \"bool\",\n          \"name\": \"isOpen\",\n          \"type\": \"bool\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"schemaId\",\n          \"type\": \"bytes32\"\n        }\n      ],\n      \"name\": \"isSchemaRegistered\",\n      \"outputs\": [\n        {\n          \"internalType\": \"bool\",\n          \"name\": \"isRegistered\",\n          \"type\": \"bool\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"string\",\n          \"name\": \"id\",\n          \"type\": \"string\"\n        },\n        {\n          \"internalType\": \"address\",\n          \"name\": \"emitter\",\n          \"type\": \"address\"\n        },\n        {\n          \"internalType\": \"bool\",\n          \"name\": \"isEmitter\",\n          \"type\": \"bool\"\n        }\n      ],\n      \"name\": \"manageEventEmitter\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"owner\",\n      \"outputs\": [\n        {\n          \"internalType\": \"address\",\n          \"name\": \"\",\n          \"type\": \"address\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"schemaId\",\n          \"type\": \"bytes32\"\n        }\n      ],\n      \"name\": \"parentSchemaId\",\n      \"outputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"parent\",\n          \"type\": \"bytes32\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"components\": [\n            {\n              \"internalType\": \"bytes32\",\n              \"name\": \"id\",\n              \"type\": \"bytes32\"\n            },\n            {\n              \"internalType\": \"bytes32\",\n              \"name\": \"schemaId\",\n              \"type\": \"bytes32\"\n            },\n            {\n              \"internalType\": \"bytes\",\n              \"name\": \"data\",\n              \"type\": \"bytes\"\n            }\n          ],\n          \"internalType\": \"struct DataSchemaLibrary.DataStream[]\",\n          \"name\": \"dataStreams\",\n          \"type\": \"tuple[]\"\n        },\n        {\n          \"components\": [\n            {\n              \"internalType\": \"string\",\n              \"name\": \"id\",\n              \"type\": \"string\"\n            },\n            {\n              \"internalType\": \"bytes32[]\",\n              \"name\": \"argumentTopics\",\n              \"type\": \"bytes32[]\"\n            },\n            {\n              \"internalType\": \"bytes\",\n              \"name\": \"data\",\n              \"type\": \"bytes\"\n            }\n          ],\n          \"internalType\": \"struct EventSource.EventData[]\",\n          \"name\": \"events\",\n          \"type\": \"tuple[]\"\n        }\n      ],\n      \"name\": \"publishDataAndEmitEvents\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"schemaId\",\n          \"type\": \"bytes32\"\n        },\n        {\n          \"internalType\": \"address\",\n          \"name\": \"publisher\",\n          \"type\": \"address\"\n        },\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"key\",\n          \"type\": \"bytes32\"\n        }\n      ],\n      \"name\": \"publisherDataExists\",\n      \"outputs\": [\n        {\n          \"internalType\": \"bool\",\n          \"name\": \"exists\",\n          \"type\": \"bool\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"schemaId\",\n          \"type\": \"bytes32\"\n        },\n        {\n          \"internalType\": \"address\",\n          \"name\": \"publisher\",\n          \"type\": \"address\"\n        },\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"key\",\n          \"type\": \"bytes32\"\n        }\n      ],\n      \"name\": \"publisherDataIndex\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"index\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"string[]\",\n          \"name\": \"ids\",\n          \"type\": \"string[]\"\n        },\n        {\n          \"components\": [\n            {\n              \"components\": [\n                {\n                  \"internalType\": \"string\",\n                  \"name\": \"name\",\n                  \"type\": \"string\"\n                },\n                {\n                  \"internalType\": \"string\",\n                  \"name\": \"paramType\",\n                  \"type\": \"string\"\n                },\n                {\n                  \"internalType\": \"bool\",\n                  \"name\": \"isIndexed\",\n                  \"type\": \"bool\"\n                }\n              ],\n              \"internalType\": \"struct EventSource.Parameter[]\",\n              \"name\": \"params\",\n              \"type\": \"tuple[]\"\n            },\n            {\n              \"internalType\": \"bytes32\",\n              \"name\": \"eventTopic\",\n              \"type\": \"bytes32\"\n            }\n          ],\n          \"internalType\": \"struct EventSource.EventSchema[]\",\n          \"name\": \"schemas\",\n          \"type\": \"tuple[]\"\n        }\n      ],\n      \"name\": \"registerEventSchemas\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"components\": [\n            {\n              \"internalType\": \"string\",\n              \"name\": \"id\",\n              \"type\": \"string\"\n            },\n            {\n              \"internalType\": \"string\",\n              \"name\": \"schema\",\n              \"type\": \"string\"\n            },\n            {\n              \"internalType\": \"bytes32\",\n              \"name\": \"parentSchemaId\",\n              \"type\": \"bytes32\"\n            }\n          ],\n          \"internalType\": \"struct DataSchemaLibrary.SchemaRegistration[]\",\n          \"name\": \"schemaRegistrations\",\n          \"type\": \"tuple[]\"\n        }\n      ],\n      \"name\": \"registerSchemas\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"renounceOwnership\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"address\",\n          \"name\": \"wallet\",\n          \"type\": \"address\"\n        },\n        {\n          \"internalType\": \"enum RoleControl.Role\",\n          \"name\": \"role\",\n          \"type\": \"uint8\"\n        }\n      ],\n      \"name\": \"revokeRole\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"schemaId\",\n          \"type\": \"bytes32\"\n        }\n      ],\n      \"name\": \"schemaIdToId\",\n      \"outputs\": [\n        {\n          \"internalType\": \"string\",\n          \"name\": \"id\",\n          \"type\": \"string\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"schemaId\",\n          \"type\": \"bytes32\"\n        }\n      ],\n      \"name\": \"schemaReverseLookup\",\n      \"outputs\": [\n        {\n          \"internalType\": \"string\",\n          \"name\": \"schema\",\n          \"type\": \"string\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bool\",\n          \"name\": \"bypass\",\n          \"type\": \"bool\"\n        }\n      ],\n      \"name\": \"setBypassRoleChecks\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"string\",\n          \"name\": \"id\",\n          \"type\": \"string\"\n        },\n        {\n          \"internalType\": \"bool\",\n          \"name\": \"isOpen\",\n          \"type\": \"bool\"\n        }\n      ],\n      \"name\": \"setIsEventEmissionOpen\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"enum RoleControl.Role\",\n          \"name\": \"role\",\n          \"type\": \"uint8\"\n        },\n        {\n          \"internalType\": \"bool\",\n          \"name\": \"isOpen\",\n          \"type\": \"bool\"\n        }\n      ],\n      \"name\": \"setIsRoleOpen\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"topic\",\n          \"type\": \"bytes32\"\n        }\n      ],\n      \"name\": \"topicRegistrationOrigin\",\n      \"outputs\": [\n        {\n          \"internalType\": \"address\",\n          \"name\": \"origin\",\n          \"type\": \"address\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"schemaId\",\n          \"type\": \"bytes32\"\n        },\n        {\n          \"internalType\": \"address\",\n          \"name\": \"publisher\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"totalPublisherDataForSchema\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [],\n      \"name\": \"totalSchemasRegistered\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"bytes32\",\n          \"name\": \"topic\",\n          \"type\": \"bytes32\"\n        }\n      ],\n      \"name\": \"totalTopicIndexedParams\",\n      \"outputs\": [\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"indexedParams\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    },\n    {\n      \"inputs\": [\n        {\n          \"internalType\": \"address\",\n          \"name\": \"newOwner\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"transferOwnership\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    }\n  ] as Abi\n}\n", "import { StreamsABI } from \"./Streams\"\nimport { ContractRef, KnownContracts } from \"@/types\"\nimport { isAddress } from \"viem\"\n\nexport async function getABI(ref: ContractRef) {\n    if (ref.internal) {\n        switch (ref.internal) {\n            case KnownContracts.STREAMS:\n                return StreamsABI()\n        }\n    } else if (ref.address) {\n        // Future: resolve ABI from Etherbase\n        if (!isAddress(ref.address, { strict: false })) {\n            throw new Error(\"Invalid address supplied\")\n        }\n        throw new Error(\"Feature not implemented\")\n    }\n}", "import { ContractRef } from \"../index\"\n\nexport function contractRefToString(ref: ContractRef) {\n    const internalRef = ref.internal ? `${ref.internal}` : \"UnknownContract\"\n    const addressRef = ref.address ? `${ref.address}` : \"InvalidAddress\"\n    return `${ref.chainId}:${internalRef}:${addressRef}`\n}", "import { getContractAddress } from \"@/services/smart-contracts/address/index\"\nimport { getABI } from \"@/services/smart-contracts/abi/index\"\nimport { ContractRef } from \"@/types\"\nimport { contractRefToString } from \"@/types/utils\"\nimport { isAddress, Abi, Address, isAddressEqual, zeroAddress } from \"viem\"\n\nexport type ContractAddressAndAbi = {\n    abi: Abi,\n    address: Address,\n}\n\nexport async function getContractAddressAndAbi(ref: ContractRef): Promise<ContractAddressAndAbi> {\n    const abi = await getABI(ref)\n    if (!abi) {\n        throw new Error(`Unable to resolve ABI for ${contractRefToString(ref)}`)\n    }\n\n    const address = await getContractAddress(ref)\n    if (!address) {\n        throw new Error(`Unable to resolve contract address for ${contractRefToString(ref)}`)\n    }\n\n    if (!isAddress(address, { strict: false })) {\n        throw new Error(`Invalid contract address for ${contractRefToString(ref)}`)\n    }\n\n    if (isAddressEqual(address, zeroAddress)) {\n        throw new Error(`No contract connected for ${contractRefToString(ref)}`)\n    }\n\n    return {\n        abi,\n        address\n    }\n}", "import { BaseError, ContractFunctionRevertedError } from \"viem\"\n\nexport function maybeLogContractError(e: unknown, context: string): Error | null {\n    let error: Error | null = null\n    if (e instanceof BaseError) {\n        const revertError = e.walk(\n            (err) => err instanceof ContractFunctionRevertedError,\n        )\n        if (revertError instanceof ContractFunctionRevertedError) {\n            const errorName = revertError.data?.errorName ?? \"UnknownError\"\n            console.log({ errorType: \"Contract Error\", context, errorName })\n            error = new Error(errorName)\n        }\n    }\n    return error\n}", "// Viem version of: https://github.com/ethereum-attestation-service/eas-sdk/blob/master/src/schema-encoder.ts\n\nimport {\n    parseAbi,\n    encodeAbiParameters,\n    decodeAbiParameters,\n    stringToHex,\n    isHex,\n    type AbiParameter,\n    type Hex,\n    zeroAddress\n} from \"viem\";\n\nexport type SchemaValue =\n  | string\n  | boolean\n  | number\n  | bigint\n  | Record<string, unknown>\n  | Record<string, unknown>[]\n  | unknown[];\n\nexport interface SchemaItem {\n  name: string;\n  type: string;\n  value: SchemaValue;\n}\n\nexport interface SchemaItemWithSignature extends SchemaItem {\n  signature: string;\n}\n\nexport interface SchemaDecodedItem {\n  name: string;\n  type: string;\n  signature: string;\n  value: SchemaItem;\n}\n\nconst TUPLE_TYPE = \"tuple\";\nconst BYTES32 = \"bytes32\";\nconst ADDRESS = \"address\";\nconst BOOL = \"bool\";\nconst IPFS_HASH = \"ipfsHash\";\n\nfunction stripAbiNames(params: readonly AbiParameter[]): AbiParameter[] {\n  return params.map((p) => {\n    if (\"components\" in p) {\n      return {\n        type: p.type,\n        components: stripAbiNames(p.components ?? []),\n      };\n    } else {\n      return { type: p.type };\n    }\n  });\n}\n\nexport class SchemaEncoder {\n  public schema: SchemaItemWithSignature[];\n  private abiParams: readonly AbiParameter[];\n  private abiParamsNoNames: AbiParameter[];\n\n  constructor(schema: string) {\n    this.schema = [];\n\n    const fixedSchema = schema.replace(new RegExp(`${IPFS_HASH} (\\\\S+)`, \"g\"), `${BYTES32} $1`);\n    const abi = parseAbi([`function func(${fixedSchema})`]);\n\n    this.abiParams = abi[0].inputs;\n    this.abiParamsNoNames = stripAbiNames(this.abiParams);\n\n    for (const input of this.abiParams) {\n      let type = input.type;\n      let signature = input.name ? `${input.type} ${input.name}` : input.type;\n      const signatureSuffix = input.name ? ` ${input.name}` : \"\";\n      let typeName = type;\n\n      const isArray = type.endsWith(\"[]\");\n      let components: readonly AbiParameter[] = [];\n      if (type.startsWith(TUPLE_TYPE)) {\n        if (!(\"components\" in input)) throw new Error(\"Missing components for tuple type\");\n        components = input.components ?? [];\n        type = `(${components.map((c) => c.type).join(\",\")})${isArray ? \"[]\" : \"\"}`;\n        signature = `(${components.map((c) => (c.name ? `${c.type} ${c.name}` : c.type)).join(\",\")})${\n          isArray ? \"[]\" : \"\"\n        }${signatureSuffix}`;\n      } else if (type.includes(\"[]\")) {\n        typeName = typeName.replace(\"[]\", \"\");\n      }\n\n      const singleValue = SchemaEncoder.getDefaultValueForTypeName(typeName);\n\n      this.schema.push({\n        name: input.name ?? \"\",\n        type,\n        signature,\n        value: type.includes(\"[]\") ? [] : singleValue\n      });\n    }\n  }\n\n  public encodeData(params: SchemaItem[]): Hex {\n    if (params.length !== this.schema.length) {\n      throw new Error(\"Invalid number or values\");\n    }\n\n    const data = [];\n\n    for (const [index, schemaItem] of this.schema.entries()) {\n      const { type, name, value } = params[index];\n      const sanitizedType = type.replace(/\\s/g, \"\");\n\n      if (\n        sanitizedType !== schemaItem.type &&\n        sanitizedType !== schemaItem.signature &&\n        !(sanitizedType === IPFS_HASH && schemaItem.type === BYTES32)\n      ) {\n        throw new Error(`Incompatible param type: ${sanitizedType}`);\n      }\n\n      if (name !== schemaItem.name) {\n        throw new Error(`Incompatible param name: ${name}`);\n      }\n\n      data.push(\n        schemaItem.type === BYTES32 && typeof value === \"string\" && !isHex(value)\n            ? stringToHex(value, { size: 32 })\n            : value\n      );\n    }\n\n    return encodeAbiParameters(this.abiParams, data);\n  }\n\n  public decodeData(data: Hex): SchemaDecodedItem[] {\n    const values = decodeAbiParameters(this.abiParamsNoNames, data);\n\n    return this.schema.map((s, i) => {\n      let value = values[i];\n      const input = this.abiParams[i];\n      const components: readonly AbiParameter[] = \"components\" in input ? input.components ?? [] : [];\n\n      if (components.length > 0) {\n        if (input.type.endsWith(\"[]\")) {\n          const namedValues: SchemaItem[][] = [];\n\n          for (const val of value as readonly unknown[][]) {\n            const namedValue: SchemaItem[] = [];\n            for (const [k, v] of val.entries()) {\n              const component = components[k];\n              namedValue.push({ name: component.name ?? \"\", type: component.type, value: v as SchemaValue });\n            }\n            namedValues.push(namedValue);\n          }\n\n          value = {\n            name: s.name,\n            type: s.type,\n            value: namedValues\n          };\n        } else {\n          const namedValue: SchemaItem[] = [];\n          for (const [k, v] of (value as readonly unknown[]).entries()) {\n            const component = components[k];\n            namedValue.push({ name: component.name ?? \"\", type: component.type, value: v as SchemaValue });\n          }\n\n          value = {\n            name: s.name,\n            type: s.type,\n            value: namedValue\n          };\n        }\n      } else {\n        value = { name: s.name, type: s.type, value: value as SchemaValue };\n      }\n\n      return {\n        name: s.name,\n        type: s.type,\n        signature: s.signature,\n        value: value as SchemaItem\n      };\n    });\n  }\n\n  public static isSchemaValid(schema: string) {\n    try {\n      new SchemaEncoder(schema);\n\n      return true;\n    } catch (_e) {\n      return false;\n    }\n  }\n\n  public isEncodedDataValid(data: Hex) {\n    try {\n      this.decodeData(data);\n\n      return true;\n    } catch (_e) {\n      return false;\n    }\n  }\n\n  private static getDefaultValueForTypeName(typeName: string) {\n    if (typeName === BOOL) return false;\n    if (typeName.includes(\"int\")) return BigInt(0);\n    if (typeName === ADDRESS) return zeroAddress;\n    return \"\";\n  }\n\n}", "import { toBytes } from \"viem\"\n\nexport const zeroBytes32 = `0x${Buffer.from(toBytes(0, { size: 32 })).toString(\"hex\")}`", "import { isAddress, isAddressEqual, zeroAddress, Address } from \"viem\"\n\nexport function assertAddressIsValid(address: Address, disableZeroAddressCheck?: boolean) {\n    if (!isAddress(address, { strict: false })) {\n        throw new Error(`Invalid address`)\n    }\n\n    if (!disableZeroAddressCheck && isAddressEqual(address, zeroAddress)) {\n        throw new Error(`Zero address supplied`)\n    }\n}", "/**\n * Imports\n */\nimport { Client, KnownContracts } from \"@/types\"\nimport { Viem } from \"@/services/viem\"\nimport { getContractAddressAndAbi } from \"@/services/smart-contracts\"\nimport { maybeLogContractError } from \"@/services/logs\"\nimport {\n    Hex,\n    Address,\n    Abi,\n    createPublicClient,\n    webSocket,\n    toEventSelector,\n    isAddressEqual,\n    zeroAddress,\n} from \"viem\"\nimport { SchemaDecodedItem, SchemaEncoder } from \"./encoder\"\nimport { zeroBytes32 } from \"@/constants\"\nimport {\n    SchemaReference,\n    DataStream,\n    EventStream,\n    EventSchema,\n    SchemaID,\n    DataSchemaRegistration,\n    ExtendedWebSocketTransport,\n    StreamsInterface,\n    SubscriptionInitParams,\n    GetSomniaDataStreamsProtocolInfoResponse,\n} from \"@/types/streams\"\nimport { assertAddressIsValid } from \"@/utils/validation\"\n\n/**\n * Exports\n */\nexport {SchemaEncoder} from \"./encoder\"\n\nexport class Streams implements StreamsInterface {\n    private viem: Viem\n\n    constructor(client: Client) {\n        this.viem = new Viem(client)\n    }\n\n    /**\n     * Adjust the accounts that can emit registered streams event schemas\n     * @dev By default, the wallet that registers an event is a defacto emitter but more can be added\n     * @dev If one wants the event to be open to all to emit, one could whitelist a smart contract and manage access externally\n     * @param streamsEventId Identifier of the registered streams event\n     * @param emitter Wallet address\n     * @param isEmitter Flag to enable or disable the emitter\n     * @returns Transaction hash if successful, Error object where applicable or null in catch all error case\n     */\n    public async manageEventEmittersForRegisteredStreamsEvent(\n        streamsEventId: string,\n        emitter: Address,\n        isEmitter: boolean\n    ): Promise<Hex | Error | null> {\n        assertAddressIsValid(emitter)\n        try {\n            // Resolve the chain id based on connected clients\n            const chainId = await this.viem.getChainId()\n\n            const {\n                address,\n                abi\n            } = await getContractAddressAndAbi({ \n                internal: KnownContracts.STREAMS,\n                chainId \n            })\n\n            return this.viem.writeContract(\n                address,\n                abi!,\n                \"manageEventEmitter\",\n                [streamsEventId, emitter, isEmitter]\n            )\n        } catch (e) {\n            console.log(\"manageEventEmitter failure\", e)\n            maybeLogContractError(e, \"Failed to manage event emitter\")\n            if (e instanceof Error) {\n                return e\n            }\n        }\n        return null\n    }\n\n    /**\n     * Gives an event registrar the ability to open an event to be emitted by anyone\n     * @param streamsEventId Identifier of the registered streams event\n     * @param isOpen Enable or disable the feature based on this flag\n     * @returns Transaction hash if successful, Error object where applicable or null in catch all error case\n     */\n    public async setIsEventEmissionOpen(\n        streamsEventId: string,\n        isOpen: boolean\n    ): Promise<Hex | Error | null> {\n        try {\n            // Resolve the chain id based on connected clients\n            const chainId = await this.viem.getChainId()\n\n            const {\n                address,\n                abi\n            } = await getContractAddressAndAbi({ \n                internal: KnownContracts.STREAMS,\n                chainId \n            })\n\n            return this.viem.writeContract(\n                address,\n                abi!,\n                \"setIsEventEmissionOpen\",\n                [streamsEventId, isOpen]\n            )\n        } catch (e) {\n            console.log(\"setIsEventEmissionOpen failure\", e)\n            maybeLogContractError(e, \"Failed to manage event emission\")\n            if (e instanceof Error) {\n                return e\n            }\n        }\n        return null\n    }\n\n    /**\n     * Publish on-chain state updates and emit associated events\n     * @dev Note that the state will be written to chain before any event(s) is/are emitted\n     * @param dataStreams Bytes stream array that has unique keys referencing schemas\n     * @param eventStreams Somnia stream event ids and associated arguments to emit EVM logs\n     * @returns Transaction hash if successful, Error object where applicable or null in catch all error case\n     */\n    public async setAndEmitEvents(\n        dataStreams: DataStream[],\n        eventStreams: EventStream[]\n    ): Promise<Hex | Error | null> {\n        try {\n            // Resolve the chain id based on connected clients\n            const chainId = await this.viem.getChainId()\n\n            const {\n                address,\n                abi\n            } = await getContractAddressAndAbi({ \n                internal: KnownContracts.STREAMS,\n                chainId \n            })\n\n            return this.viem.writeContract(\n                address,\n                abi!,\n                \"publishDataAndEmitEvents\",\n                [dataStreams, eventStreams]\n            )\n        } catch (e) {\n            console.log(\"publishDataAndEmitEvents failure\", e)\n            maybeLogContractError(e, \"Failed to publish data and emit events\")\n            if (e instanceof Error) {\n                return e\n            }\n        }\n        return null\n    }\n\n    /**\n     * Register a set of event schemas that can emit EVM logs later referenced by an arbitrary ID\n     * @param ids Arbirary identifiers that will be asigned to event schmas\n     * @param schemas Unique event schemas that contain an event topic and a specified number of indexed and non-indexed params\n     * @returns Transaction hash if successful, Error object where applicable or null in catch all error case\n     */\n    public async registerEventSchemas(\n        ids: string[],\n        schemas: EventSchema[]\n    ): Promise<Hex | Error | null> {\n        try {\n            // Resolve the chain id based on connected clients\n            const chainId = await this.viem.getChainId()\n\n            const {\n                address,\n                abi\n            } = await getContractAddressAndAbi({ \n                internal: KnownContracts.STREAMS,\n                chainId \n            })\n\n            // Allow for event signatures to be supplied which will then compute the event selector\n            const schemasToRegister: EventSchema[] = schemas.map(schema => {\n                let updatedTopic = schema.eventTopic\n                if (updatedTopic.indexOf(\"0x\") === -1) {\n                    updatedTopic = toEventSelector(updatedTopic)\n                }\n                return {\n                    params: schema.params,\n                    eventTopic: updatedTopic\n                }\n            })\n\n            // Fire the register event schema\n            return this.viem.writeContract(\n                address,\n                abi!,\n                \"registerEventSchemas\",\n                [ids, schemasToRegister]\n            )\n        } catch (e) {\n            console.log(\"registerEventSchemas failure\", e)\n            maybeLogContractError(e, \"Failed to register event schema\")\n            if (e instanceof Error) {\n                return e\n            }\n        }\n        return null\n    }\n\n    /**\n     * Emit EVM event logs on-chain for events that have registered schemas on the Somnia streams protocol\n     * @param events Somnia stream event ids and associated arguments to emit EVM logs\n     * @returns Transaction hash if successful, Error object where applicable or null in catch all error case\n     */\n    public async emitEvents(\n        events: EventStream[]\n    ): Promise<Hex | Error | null> {\n        try {\n            // Resolve the chain id based on connected clients\n            const chainId = await this.viem.getChainId()\n            \n            // Fetch the contract address and abi based on the connected chain\n            const {\n                address,\n                abi\n            } = await getContractAddressAndAbi({ \n                internal: KnownContracts.STREAMS,\n                chainId \n            })\n\n            // Execute the transaction to emit the event schema\n            return this.viem.writeContract(\n                address,\n                abi!,\n                \"emitEvents\",\n                [events]\n            )\n        } catch (e) {\n            console.log(\"emitEvents failure\", e)\n            maybeLogContractError(e, \"Failed to emit events\")\n            if (e instanceof Error) {\n                return e\n            }\n        }\n        return null\n    }\n\n    /**\n     * Compute the bytes32 keccak256 hash of the schema - used as the schema identifier\n     * @param schema The solidity compatible schema encoded in a string\n     * @returns The bytes32 schema ID\n     */\n    public async computeSchemaId(schema: string): Promise<Hex | null> {\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            // Get the schema id\n            return this.viem.readContract<Hex>(\n                address,\n                abi,\n                \"computeSchemaId\",\n                [schema]\n            )\n        } catch (e) {\n            console.error(e)\n        }\n        return null\n    }\n\n    /**\n     * Query the contract to check whether a data schema is already registered based on a known schema ID\n     * @param schemaId Hex schema ID that is a bytes32 solidity value\n     * @returns Boolean denoting registration or null if it was not possible to register that info\n     */\n    public async isDataSchemaRegistered(schemaId: SchemaID): Promise<boolean | null> {\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            // Get the schema id\n            return this.viem.readContract<boolean>(\n                address,\n                abi,\n                \"isSchemaRegistered\",\n                [schemaId]\n            )\n        } catch (e) {\n            console.error(e)\n        }\n        return null\n    }\n\n    /**\n     * Total data points published on-chain by a specific wallet for a given schema\n     * @param schemaId Unique hex reference to the schema (bytes32 value)\n     * @param publisher Address of the wallet or smart contract that published the data\n     * @returns An unsigned integer or null if the information could not be retrieved\n     */\n    public async totalPublisherDataForSchema(\n        schemaId: SchemaID,\n        publisher: Address\n    ): Promise<bigint | null> {\n        assertAddressIsValid(publisher)\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            // Get the schema id\n            return this.viem.readContract<bigint>(\n                address,\n                abi,\n                \"totalPublisherDataForSchema\",\n                [schemaId, publisher]\n            )\n        } catch (e) {\n            console.error(e)\n        }\n        return null\n    }\n\n    /**\n     * Given knowledge re total data published under a schema for a publisher, get data in a specified range\n     * @param schemaId Unique hex reference to the schema (bytes32 value)\n     * @param publisher Address of the wallet or smart contract that published the data\n     * @param startIndex BigInt start of the range (inclusive)\n     * @param endIndex BigInt end of the range (exclusive)\n     * @returns Raw bytes array if the schema is private, decoded data array if schema is valid, error or null when something goes wrong\n     */\n    public async getBetweenRange(\n        schemaId: SchemaID,\n        publisher: Address,\n        startIndex: bigint,\n        endIndex: bigint\n    ): Promise<Hex[] | SchemaDecodedItem[][] | Error | null> {\n        // Ensure the publisher address is valid\n        assertAddressIsValid(publisher)\n\n        // Get data between range\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            // Read from chain with a single multicall call that avoids contractViewCalls.length rpc calls\n            const rawData = await this.viem.readContract<Hex[]>(\n                address,\n                abi,\n                \"getPublisherDataForSchemaInRange\",\n                [schemaId, publisher, startIndex, endIndex]\n            )\n\n            // Extract the raw data and ask the SDK to deserialise using the data schema specified\n            return this.deserialiseRawData(rawData, schemaId)\n        } catch (e) {\n            console.log(\"getBetweenRange failure\", e)\n            maybeLogContractError(e, \"getBetweenRange: Failed to get data\")\n            if (e instanceof Error) {\n                return e\n            }\n        }\n        return null\n    }\n\n    /**\n     * Read historical published data for a given schema at a known index\n     * @param schemaId Unique schema reference that can be computed from the full schema\n     * @param publisher Wallet that published the data\n     * @param idx Index of the data in an append only list associated with the data publisher wallet\n     * @returns Raw data as a hex string if the schema is private, deserialised data or null if the data does not exist\n     */\n    public async getAtIndex(\n        schemaId: SchemaID,\n        publisher: Address,\n        idx: bigint\n    ): Promise<Hex[] | SchemaDecodedItem[][] | null> {\n        assertAddressIsValid(publisher)\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            // Read from chain\n            const rawData = await this.viem.readContract<Hex>(\n                address,\n                abi,\n                \"getPublisherDataForSchemaAtIndex\",\n                [schemaId, publisher, idx]\n            )\n\n            return this.deserialiseRawData([rawData], schemaId)\n        } catch (e) {\n            console.error(e)\n        }\n        return null\n    }\n\n    /**\n     * Fetches the parent schema of another schema which is important metadata when deserialising data associated with a schema that extends a parent schema\n     * @param schemaId Hex identifier of the schema being queried\n     * @returns A hex value (bytes32) that is fully zero'd if there is no parent or null if the info cannot be retrieved\n     */\n    public async parentSchemaId(schemaId: SchemaID): Promise<Hex | null> {\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            // Get the schema id\n            return this.viem.readContract<Hex>(\n                address,\n                abi,\n                \"parentSchemaId\",\n                [schemaId]\n            )\n        } catch (e) {\n            console.error(e)\n        }\n        return null\n    }\n\n    /**\n     * Query the unique human readable identifier for a schema\n     * @param schemaId Hex encoded schema ID computed from the raw schema using computeSchemaId\n     * @returns The human readable identifier for a schema\n     */\n    public async schemaIdToId(schemaId: SchemaID): Promise<string | null> {\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            // Get the schema id\n            return this.viem.readContract<Hex>(\n                address,\n                abi,\n                \"schemaIdToId\",\n                [schemaId]\n            )\n        } catch (e) {\n            console.error(e)\n        }\n        return null\n    }\n\n    /**\n     * Lookup the Hex schema ID for a given unique human readable identifer\n     * @param id Human readable identifier\n     * @returns Hex schema id (bytes32 solidity type)\n     */\n    public async idToSchemaId(id: string): Promise<Hex | null> {\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            // Get the schema id\n            return this.viem.readContract<Hex>(\n                address,\n                abi,\n                \"idToSchemaId\",\n                [id]\n            )\n        } catch (e) {\n            console.error(e)\n        }\n        return null\n    }\n\n    /**\n     * Batch register multiple schemas that can be used to write state to chain\n     * @param registrations Array of raw schemas and any parent schemas associated (if extending a schema)\n     * @returns Transaction hash if successful, Error if one is present or null if something failed\n     */\n    public async registerDataSchemas(\n        registrations: DataSchemaRegistration[],\n        ignoreRegisteredSchemas?: boolean\n    ): Promise<Hex | Error | null> {\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            let schemasToRegister: DataSchemaRegistration[] = registrations.map(registration => ({\n                id: registration.id,\n                schema: registration.schema,\n                parentSchemaId: (registration.parentSchemaId ? registration.parentSchemaId : zeroBytes32) as Hex\n            }))\n\n            if (ignoreRegisteredSchemas) {\n                // Perform additional calls to check if the schemas are already registered\n                const registrationsWithStatus = await Promise.all(registrations.map(async (registration) => {\n                    const schemaId = await this.computeSchemaId(registration.schema)\n                    return {\n                        id: registration.id,\n                        schema: registration.schema,\n                        parentSchemaId: (registration.parentSchemaId ? registration.parentSchemaId : zeroBytes32) as Hex,\n                        isRegistered: schemaId ? await this.isDataSchemaRegistered(schemaId) : false\n                    }\n                }))\n\n                // Filter for only unregistered schemas\n                schemasToRegister = registrationsWithStatus\n                    .filter((registration) => !registration.isRegistered)\n                    .map((registration) => ({\n                        id: registration.id,\n                        schema: registration.schema,\n                        parentSchemaId: registration.parentSchemaId\n                    }))\n            }\n\n            if (schemasToRegister.length === 0) {\n                throw new Error(\"Nothing to register\")\n            }\n\n            return this.viem.writeContract(\n                address,\n                abi,\n                \"registerSchemas\",\n                [schemasToRegister]\n            )\n        } catch (e) {\n            console.log(\"manageEventEmitter failure\", e)\n            maybeLogContractError(e, \"Failed to manage event emitter\")\n            if (e instanceof Error) {\n                return e\n            }\n        }\n        return null\n    }\n\n    /**\n     * Write data to chain using data streams that can be parsed by schemas\n     * @param dataStreams Bytes stream array that has unique keys referencing schemas\n     * @returns Transaction hash or null if there are issues writing to chain\n     */\n    public async set(\n        dataStreams: DataStream[]\n    ): Promise<Hex | null> {\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            return this.viem.writeContract(\n                address,\n                abi,\n                \"esstores\",\n                [dataStreams]\n            )\n        } catch (e) {\n            console.error(e)\n        }\n        return null\n    }\n\n    /**\n     * Fetches all raw, registered public schemas that can be used to deserialise data associated with the schema ids\n     * @returns Array of full schemas or null if there was an issue fetching schemas\n     */\n    public async getAllSchemas(): Promise<string[] | null> {\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            return this.viem.readContract<string[]>(\n                address,\n                abi,\n                \"getAllSchemas\"\n            )\n        } catch (e) {\n            console.error(e)\n        }\n        return null\n    }\n\n    /**\n     * Query Somnia Data streams for all data published by a specific wallet for a given schema\n     * @param schemaId Unique schema reference to a public or private schema or the full schema\n     * @param publisher Wallet that broadcast the data on-chain\n     * @returns A hex array with (raw data) for private schemas, SchemaDecodedItem 2D array for decoded data or null for errors reading from chain\n     */\n    public async getAllPublisherDataForSchema(\n        schemaId: SchemaID,\n        publisher: Address\n    ): Promise<Hex[] | SchemaDecodedItem[][] | null> {\n        assertAddressIsValid(publisher)\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            // Read from chain\n            const rawData = await this.viem.readContract<Hex[]>(\n                address,\n                abi,\n                \"getAllPublisherDataForSchema\",\n                [schemaId, publisher]\n            )\n\n            return this.deserialiseRawData(rawData, schemaId)\n        } catch (e) {\n            console.error(e)\n        }\n        return null\n    }\n\n    /**\n     * Read state from the Somnia streams protocol that was written via set or setAndEmitEvents\n     * @param schemaId Unique hex identifier for the schema associated with the raw data written to chain\n     * @param publisher Address of the wallet that wrote the data to chain\n     * @param key Unique reference to the data being read\n     * @returns The raw data\n     */\n    public async getByKey(\n        schemaId: SchemaID,\n        publisher: Address,\n        key: Hex\n    ): Promise<Hex[] | SchemaDecodedItem[][] | null> {\n        assertAddressIsValid(publisher)\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            // Get the index associated with the data key\n            const index = await this.viem.readContract<bigint>(\n                address,\n                abi,\n                \"publisherDataIndex\",\n                [schemaId, publisher, key]\n            )\n\n            return this.getAtIndex(\n                schemaId,\n                publisher,\n                index\n            )\n        } catch (e) {\n            console.error(e)\n        }\n        return null\n    }\n\n    /**\n     * Gets a set of regisered event schemas based on a set of known event schema identifiers assigned at registration\n     * @param ids Set of event schema identifiers given to registered event topics\n     * @returns Set of event schemas or null if the data cannot be read from chain\n     */\n    public async getEventSchemasById(ids: string[]): Promise<EventSchema[] | null> {\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            return this.viem.readContract<EventSchema[]>(\n                address,\n                abi,\n                \"getEventSchemasById\",\n                [ids]\n            )\n        } catch (e) {\n            console.log(e)\n        }\n        return null\n    }\n\n    /**\n     * If there published data for a given schema, this returns the last published data\n     * @dev this assumes that last published data is at the end of the array of all publisher data points\n     * @param schemaId Unique schema identifier\n     * @param publisher Wallet address of the publisher \n     * @returns Raw data from chain if schema is not public, decoded data if it is or null if there were errors reading data\n     */\n    public async getLastPublishedDataForSchema(\n        schemaId: SchemaID,\n        publisher: Address\n    ): Promise<Hex[] | SchemaDecodedItem[][] | null> {\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            // Read the last published bytes data from chain\n            const rawData = await this.viem.readContract<Hex>(\n                address,\n                abi,\n                \"getLastPublishedDataForSchema\",\n                [schemaId, publisher]\n            )\n\n            return this.deserialiseRawData([rawData], schemaId)\n        } catch (e) {\n            console.log(e)\n        }\n        return null\n    }\n\n    /**\n     * Based on the connected viem public client, will return the address, abi and connected chain id\n     * @returns Protocol info if there is one defined for the target chain, an error if that was not possible or null in a catch all error scenario\n     */\n    public async getSomniaDataStreamsProtocolInfo(): Promise<\n        GetSomniaDataStreamsProtocolInfoResponse | Error | null\n    > {\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            return {\n                address,\n                abi,\n                chainId\n            }\n        } catch (e) {\n            console.log(e)\n            if (e instanceof Error) {\n                return e\n            }\n        }\n        return null\n    }\n\n    /**\n     * Somnia streams reactivity enabling event subscriptions that bundle any ETH call data\n     * @param param0 See SubscriptionInitParams type which defines the events being observed, the eth calls executed and what callback fn to call\n     * @returns The subscription identifier and an unsubscribe callback or undefined if the subscription fails to start\n     */\n    public async subscribe({\n        somniaStreamsEventId,\n        ethCalls,\n        context,\n        onData,\n        onError,\n        eventContractSources,\n        topicOverrides,\n        onlyPushChanges\n    }: SubscriptionInitParams): Promise<{ subscriptionId: string, unsubscribe: () => void } | undefined> {\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the streams contract address as the default event source\n            const { address: streamsProtocolAddress } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            // Ensure the transport type is websocket otherwise we cannot proceed\n            if (this.viem.client.public.transport.type !== \"webSocket\") {\n                throw new Error(\"Invalid public client config - websocket required\")\n            }\n\n            // If an override for event source has been specified use it otherwise use the Streams contract address\n            let eventSources: Address[] | undefined = undefined\n            let eventTopics: Hex[] | undefined = undefined\n            if (somniaStreamsEventId) {\n                // Fetch the topic info from the streams contract by id\n                let eventSchemas: EventSchema[] | null = null\n                try {\n                    eventSchemas = await this.getEventSchemasById([somniaStreamsEventId])\n                } catch {\n                    throw new Error(\"Failed to get event schemas\")\n                }\n\n                if (!eventSchemas) {\n                    throw new Error(\"Event schemas not returned\")\n                }\n\n                if (eventSchemas.length < 1) {\n                    throw new Error(\"No event schema returned\")\n                }\n\n                if (eventSchemas.length > 1) {\n                    throw new Error(\"Too many schemas found\")\n                }\n\n                const [eventSchema] = eventSchemas\n                const { eventTopic } = eventSchema\n\n                // Push a single topic for to watch\n                eventTopics = [eventTopic as Hex]\n\n                // Push a single contract to watch\n                eventSources = [streamsProtocolAddress]\n            } else {\n                eventSources = eventContractSources\n                eventTopics = topicOverrides   \n            }\n\n            // get a public client with the correct websocket types already figured out\n            const webSocketClient = createPublicClient({\n                chain: this.viem.client.public.chain,\n                transport: webSocket(),  // Defaults to chain's WS URL\n            }) as unknown as { transport: ExtendedWebSocketTransport };\n\n            // Subscribe and return the subscription info to the caller\n            const somniaWatchParams = {\n                address: eventSources,\n                topics: eventTopics,\n                eth_calls: ethCalls,\n                context,\n                push_changes_only: onlyPushChanges\n            }\n            console.log(\"somniaWatchParams\", somniaWatchParams)\n\n            return webSocketClient.transport.subscribe({\n                params: [\n                    \"somnia_watch\",\n                    somniaWatchParams\n                ],\n                onData,\n                onError\n            })\n        } catch (e) {\n            console.log(e)\n        }\n    }\n\n    /**\n     * From raw bytes data, deserialise the raw data based on a given public schema\n     * @param rawData The array of data that will be deserialised based on the specified schema\n     * @param schemaId The bytes32 schema identifier used to lookup the schema that is needed for deserialisation\n     * @returns The raw data if the schema is public, the decoded items for each item of raw data or null if there was an issue (catch all)\n     */\n    public async deserialiseRawData(\n        rawData: Hex[],\n        schemaId: SchemaID\n    ): Promise<Hex[] | SchemaDecodedItem[][] | null> {\n        try {\n            // Resolve the chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            const schemaLookup = await this.schemaLookup(address, abi, schemaId)\n            let finalSchema = schemaLookup?.finalSchema\n            if (finalSchema) {\n                const encoder = new SchemaEncoder(finalSchema)\n                const decodedData = rawData.map((raw: Hex) => (encoder.decodeData(raw)))\n                return decodedData\n            }\n\n            // Return the raw data without decoding direct from chain since we didn't have a public schema\n            return rawData\n        } catch (e) {\n            console.error(e)\n        }\n        return null\n    }\n\n    /**\n     * Request a schema given the schema id used for data publishing and let the SDK take care of schema extensions\n     * @param schemaId The bytes32 unique identifier for a base schema\n     * @returns Schema info if it is public, Error or null if there is a problem retrieving schema ID\n     */\n    public async getSchemaFromSchemaId(\n        schemaId: SchemaID\n    ): Promise<{\n        baseSchema: string\n        finalSchema: string\n        schemaId: Hex\n    } | Error | null> {\n        try {\n            // Resolve the connected chain id\n            const chainId = await this.viem.getChainId()\n\n            // Fetch the required contract info\n            const { address, abi } = await getContractAddressAndAbi({\n                internal: KnownContracts.STREAMS,\n                chainId\n            })\n\n            // Do the base schema lookup and check if the schema has extended other schemas\n            const schemaLookup = await this.schemaLookup(\n                address,\n                abi,\n                schemaId\n            )\n            if (!schemaLookup) {\n                throw new Error(`Unable to do schema lookup on [${schemaId}]`)\n            }\n\n            return schemaLookup\n        } catch (e) {\n            console.log(e)\n            if (e instanceof Error) {\n                return e\n            }\n        }\n        return null\n    }\n\n    private async schemaLookup(\n        contract: Address,\n        abi: Abi,\n        schemaRef: SchemaReference\n    ): Promise<{\n        baseSchema: string\n        finalSchema: string\n        schemaId: Hex\n    } | null> {\n        // Ensure there is some data to process\n        if (schemaRef.length === 0 || schemaRef.trim().length === 0) {\n            throw new Error(\"Invalid schema or schema ID (zero data)\")\n        }\n\n        // Lets resolve the schema ID\n        // We either have the raw base schema (without the parent schema(s)) or direct schema Id for the base\n        let schemaId: Hex | null = null\n        let lookupSchemaOnchain = true\n        if (schemaRef.indexOf(\"0x\") === -1 && schemaRef.indexOf(\"0X\") === -1) {\n            // we dont need to do an onchain schema id -> schema look up as we already have the schema\n            // but we should still compute the schema Id\n            schemaId = await this.computeSchemaId(schemaRef)\n            if (!schemaId) {\n                return null\n            }\n\n            // no need to look the schema up on-chain since we have it\n            lookupSchemaOnchain = false\n        } else {\n            schemaId = schemaRef as Hex\n        }\n\n        // Request info from the chain to see \n        // 1. if the schema is public\n        // 2. if there is a parent schema associated\n        const [baseSchemaLookup, parentSchemaId] = await Promise.all([\n            lookupSchemaOnchain ? this.viem.readContract<string>(\n                contract,\n                abi,\n                \"schemaReverseLookup\",\n                [schemaId]\n            ) : Promise.resolve(schemaRef),\n            this.viem.readContract<Hex>(\n                contract,\n                abi,\n                \"parentSchemaId\",\n                [schemaId]\n            ),\n        ])\n\n        // Lookup parent schema if the base schema has extended another\n        let parentSchema: string | null = null\n        if (parentSchemaId !== zeroBytes32) {\n            // TODO - this is only handling depth of 1 we need to handle more\n            parentSchema = await this.viem.readContract<string>(\n                contract,\n                abi,\n                \"schemaReverseLookup\",\n                [parentSchemaId]\n            )\n            console.log(\"Parent schema is associated with the schema\", { parentSchema })\n        }\n\n        // Compute the final schema factoring in any parent schemas\n        let finalSchema = baseSchemaLookup\n        if (parentSchema) {\n            finalSchema = `${finalSchema}, ${parentSchema}`\n        }\n\n        if (finalSchema.length === 0) {\n            console.warn(\"Unable to compute final schema\")\n            return null\n        }\n\n        // Return the info to be consumed internally and externally\n        return {\n            baseSchema: baseSchemaLookup,\n            finalSchema,\n            schemaId\n        }\n    }\n\n}", "// Dependencies for SDK class\nimport { Client } from \"@/types\"\nimport {\n    Streams,\n} from \"@/modules\"\n\n// Exports for SDK consumers\nexport { zeroBytes32 } from \"@/constants\"\nexport { SchemaEncoder } from \"@/modules\"\nexport { SubscriptionCallback, SubscriptionInitParams } from \"@/types/streams\"\n\nexport class SDK {\n    // Public modules that can be accessed on the SDK instance\n    streams: Streams\n\n    /**\n     * Create a new SDK instance\n     * @param client Viem wrapper object for consuming the public client and optionally the wallet client for transactions\n     */\n    constructor(client: Client) {\n        this.streams = new Streams(client)\n    }\n\n}"],
  "mappings": "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",
  "names": ["Viem", "client", "contractInfo", "getContractViem", "address", "abi", "functionName", "args", "value", "account", "hash", "accounts", "STREAMS_LIBRARY_BY_CHAIN", "zeroAddress", "getAddress", "KnownContractsByChain", "getContractAddress", "ref", "isAddress", "StreamsABI", "getABI", "contractRefToString", "internalRef", "addressRef", "getContractAddressAndAbi", "isAddressEqual", "maybeLogContractError", "e", "context", "error", "BaseError", "revertError", "err", "ContractFunctionRevertedError", "errorName", "TUPLE_TYPE", "BYTES32", "ADDRESS", "BOOL", "IPFS_HASH", "stripAbiNames", "params", "p", "SchemaEncoder", "_SchemaEncoder", "schema", "fixedSchema", "parseAbi", "input", "type", "signature", "signatureSuffix", "typeName", "isArray", "components", "c", "singleValue", "data", "index", "schemaItem", "name", "sanitizedType", "isHex", "stringToHex", "encodeAbiParameters", "values", "decodeAbiParameters", "s", "i", "namedValues", "val", "namedValue", "k", "v", "component", "zeroBytes32", "toBytes", "assertAddressIsValid", "disableZeroAddressCheck", "Streams", "streamsEventId", "emitter", "isEmitter", "chainId", "isOpen", "dataStreams", "eventStreams", "ids", "schemas", "schemasToRegister", "updatedTopic", "toEventSelector", "events", "schemaId", "publisher", "startIndex", "endIndex", "rawData", "idx", "id", "registrations", "ignoreRegisteredSchemas", "registration", "key", "somniaStreamsEventId", "ethCalls", "onData", "onError", "eventContractSources", "topicOverrides", "onlyPushChanges", "streamsProtocolAddress", "eventSources", "eventTopics", "eventSchemas", "eventSchema", "eventTopic", "webSocketClient", "createPublicClient", "webSocket", "somniaWatchParams", "finalSchema", "encoder", "raw", "schemaLookup", "contract", "schemaRef", "lookupSchemaOnchain", "baseSchemaLookup", "parentSchemaId", "parentSchema", "SDK"]
}
